package br.ufop.itc2021.algorithm.neighborhood;

import br.ufop.itc2021.Main;
import br.ufop.itc2021.algorithm.mip.MIPFull;
import br.ufop.itc2021.model.Instance;
import br.ufop.itc2021.model.Solution;
import gurobi.GRB;
import gurobi.GRBException;

import java.util.ArrayList;
import java.util.Random;

/**
 * This class represents a Fix-Opt MIP neighborhood based on teams.
 * A neighbor in this neighborhood is generated by releasing the variables
 * related to a set of teams and optimizing the MIP model regarding them.
 *
 * @author George Fonseca
 */
public class TeamsFixOpt extends MoveToCompound {

    private MIPFull mip;
    private static int neighborhoodSize = 5;
    private static int noNewSoln = 0;
    private static int maxNoNewSoln = 3;

    /**
     * Instantiates a new TeamsFixOpt Move.
     *
     * @param inst     problem.
     * @param random   random number generator.
     * @param weight the weight of this neighborhood.
     */
    public TeamsFixOpt(Instance inst, Random random, int weight, MIPFull mip) {
        super(inst, random, "TeamsMIP", weight);
        this.mip = mip;
    }

    public void accept() {
        super.accept();
    }

    public long doMove(Solution solution) {
        super.doMove(solution);
        try {
            // update model if input solution is now feasible
            if (solution.getInfeas() == 0 && mip.phase == 1) {
                mip.phase = 2;
                mip.createModel();
                mip.setModelParams();
            }
            this.mip.importSolution(solution);

            ArrayList<Integer> remainingTeams = new ArrayList<>();
            for (int t = 0; t < inst.nTeams; ++t)
                remainingTeams.add(t);
            ArrayList<Integer> selectedTeams = new ArrayList<>();

            while (selectedTeams.size() < neighborhoodSize && selectedTeams.size() < this.inst.nTeams) {
                // randomly selects a team t to be freed
                int t = remainingTeams.get(random.nextInt(remainingTeams.size()));
                selectedTeams.add(t);
                remainingTeams.remove((Object) t);
            }

            // fix/release variables
            for (int i = 0; i < inst.nTeams; ++i) {
                for (int j = 0; j < inst.nTeams; ++j) {
                    if (i != j) {
                        for (int k = 0; k < inst.nSlots; ++k) {
                            if (selectedTeams.contains(i) || selectedTeams.contains(j)) {
                                this.mip.x[i][j][k].set(GRB.DoubleAttr.LB, 0.0);
                                this.mip.x[i][j][k].set(GRB.DoubleAttr.UB, 1.0);
                            } else {
                                this.mip.x[i][j][k].set(GRB.DoubleAttr.LB, this.mip.x[i][j][k].get(GRB.DoubleAttr.Start));
                                this.mip.x[i][j][k].set(GRB.DoubleAttr.UB, this.mip.x[i][j][k].get(GRB.DoubleAttr.Start));
                            }
                        }
                    }
                }
            }

            // set the time limit and adjust it if there no remaining time enough for one iteration
            this.mip.setTimeLimit(mip.fixOptTimeLimit);
            int remainingTime = (int) ((Main.startTimeMillis + Main.timeLimit - System.currentTimeMillis()) / 1000);
            if (remainingTime < mip.fixOptTimeLimit) {
                if (remainingTime > 1)
                    this.mip.setTimeLimit(remainingTime);
                else // make sure it loads the initial solution
                    this.mip.setTimeLimit(1);
            }

            // solve the sub-problem
            this.mip.solveModel();

            // assert there is at least one solution
            if (this.mip.getModel().get(GRB.IntAttr.SolCount) == 0)
                return deltaCost = solution.getCost() - initialTotalCost;

//            System.out.printf("| t | %5d | %5d | %5.0f | %5.0f | %5.2f | %s\n",
//                    neighborhoodSize, this.mip.getModel().get(GRB.IntAttr.NumVars),
//                    this.mip.getModel().get(GRB.DoubleAttr.ObjBound),
//                    this.mip.getModel().get(GRB.DoubleAttr.ObjVal),
//                    this.mip.getModel().get(GRB.DoubleAttr.Runtime), selectedTeams);

            // auto-adaption of parameter n
            int status = this.mip.getModel().get(GRB.IntAttr.Status);
            double objValue = this.mip.getModel().get(GRB.DoubleAttr.ObjVal);
            if (status == GRB.Status.OPTIMAL) {
                if ((this.mip.phase == 1 && objValue == solution.getInfeas()) ||
                        (this.mip.phase == 2 && objValue == solution.getCost())) {
                    // no new best solution has been found =(
                    ++noNewSoln;
                    if (noNewSoln == maxNoNewSoln) {
                        // increase sub-problem size
                        noNewSoln = 0;
                        ++neighborhoodSize;
                    }
                }
                if (neighborhoodSize >= inst.nTeams) {
                    // solution is proven optimal!
                    System.out.println(String.format("Solution is optimal! Cost: %f", objValue));
                }
            }
            else { // sub-problem is too hard for timeLimit - reduce its size
                --neighborhoodSize;
                noNewSoln = 0;
            }

            // export solution
            this.mip.exportSolution(solution);
        } catch (GRBException e) {
            e.printStackTrace();
        }
        return deltaCost = solution.getCost() - initialTotalCost;
    }

}
