package br.ufop.itc2021.algorithm.neighborhood;

import br.ufop.itc2021.*;
import br.ufop.itc2021.algorithm.mip.*;
import br.ufop.itc2021.model.*;
import gurobi.*;

import java.util.*;

/**
 * This class represents a Fix-Opt MIP neighborhood based on slots.
 * A neighbor in this neighborhood is generated by releasing the variables
 * related to a set of slots and optimizing the MIP model regarding them.
 *
 * @author George Fonseca
 */
public class SlotsFixOpt extends MoveToCompound {

    private MIPFull mip;
    private static int neighborhoodSize = 10;
    private static int noNewSoln = 0;
    private static int maxNoNewSoln = 3;

    /**
     * Instantiates a new SlotsFixOpt Move.
     *
     * @param inst     problem.
     * @param random   random number generator.
     * @param weight the weight of this neighborhood.
     */
    public SlotsFixOpt(Instance inst, Random random, int weight, MIPFull mip) {
        super(inst, random, "SlotsMIP", weight);
        this.mip = mip;
    }

    public void accept() {
        super.accept();
    }

    public long doMove(Solution solution) {
        super.doMove(solution);
        try {
            // update model if input solution is now feasible
            if (solution.getInfeas() == 0 && mip.phase == 1) {
                mip.phase = 2;
                mip.createModel();
                mip.setModelParams();
            }
            this.mip.importSolution(solution);
            // vector to represent which variables will be freed
            boolean[][][] xFree = new boolean[inst.nTeams][inst.nTeams][inst.nSlots];

            ArrayList<Integer> remainingSlots = new ArrayList<>();
            for (int s = 0; s < inst.nSlots; ++s)
                remainingSlots.add(s);
            ArrayList<Integer> selectedSlots = new ArrayList<>();

            while (selectedSlots.size() < neighborhoodSize  && selectedSlots.size() < this.inst.nSlots) {
                // randomly selects a slot s to be freed
                int s = remainingSlots.get(random.nextInt(remainingSlots.size()));
                selectedSlots.add(s);
                remainingSlots.remove((Object) s);
                // add the next slot if possible
                int s2 = s + 1;
                if (selectedSlots.size() < neighborhoodSize && s2 < inst.nSlots && remainingSlots.contains(s2)) {
                    selectedSlots.add(s2);
                    remainingSlots.remove((Object) s2);
                }
//                // add the previous slot if possible
//                int s3 = s - 1;
//                if (selectedSlots.size() < neighborhoodSize && s3 >= 0 && remainingSlots.contains(s3)) {
//                    selectedSlots.add(s3);
//                    remainingSlots.remove((Object) s3);
//                }
            }

            //set up which variables will be freed
            for (int k = 0; k < inst.nSlots; ++k) {
                if (selectedSlots.contains(k)) {
                    for (int i = 0; i < inst.nTeams; ++i) {
                        for (int j = 0; j < inst.nTeams; ++j) {
                            if (i != j) {
                                xFree[i][j][k] = true;
                                // also release variables in the slot that holds the reverse game
                                if (this.mip.x[i][j][k].get(GRB.DoubleAttr.Start) > 0.999) {
                                    for(int k2 = 0; k2 < inst.nSlots; ++k2) {
                                        if (this.mip.x[j][i][k2].get(GRB.DoubleAttr.Start) > 0.999) {
                                            xFree[i][j][k2] = true;
                                            xFree[j][i][k2] = true;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            // do release/fix vars
            for (int k = 0; k < inst.nSlots; ++k) {
                for (int i = 0; i < inst.nTeams; ++i) {
                    for (int j = 0; j < inst.nTeams; ++j) {
                        if (i != j) {
                            if (xFree[i][j][k]) {
                                this.mip.x[i][j][k].set(GRB.DoubleAttr.LB, 0.0);
                                this.mip.x[i][j][k].set(GRB.DoubleAttr.UB, 1.0);
                            }
                            else {
                                this.mip.x[i][j][k].set(GRB.DoubleAttr.LB, this.mip.x[i][j][k].get(GRB.DoubleAttr.Start));
                                this.mip.x[i][j][k].set(GRB.DoubleAttr.UB, this.mip.x[i][j][k].get(GRB.DoubleAttr.Start));
                            }
                        }
                    }
                }
            }

            // set the time limit and adjust it if there no remaining time enough for one iteration
            this.mip.setTimeLimit(mip.fixOptTimeLimit);
            int remainingTime = (int) ((Main.startTimeMillis + Main.timeLimit - System.currentTimeMillis()) / 1000);
            if (remainingTime < mip.fixOptTimeLimit) {
                if (remainingTime > 1)
                    this.mip.setTimeLimit(remainingTime);
                else // make sure it loads the initial solution
                    this.mip.setTimeLimit(1);
            }

            // solve the sub-problem
            this.mip.solveModel();

            // assert there is at least one solution
            if (this.mip.getModel().get(GRB.IntAttr.SolCount) == 0)
                return deltaCost = solution.getCost() - initialTotalCost;

//            System.out.printf("| s | %5d | %5d | %5.0f | %5.0f | %5.2f | %s\n",
//                    neighborhoodSize, this.mip.getModel().get(GRB.IntAttr.NumVars),
//                    this.mip.getModel().get(GRB.DoubleAttr.ObjBound),
//                    this.mip.getModel().get(GRB.DoubleAttr.ObjVal),
//                    this.mip.getModel().get(GRB.DoubleAttr.Runtime), selectedSlots);

            // auto-adaption of parameter n
            int status = this.mip.getModel().get(GRB.IntAttr.Status);
            double objValue = this.mip.getModel().get(GRB.DoubleAttr.ObjVal);
            if (status == GRB.Status.OPTIMAL) {
                if ((this.mip.phase == 1 && objValue == solution.getInfeas()) ||
                        (this.mip.phase == 2 && objValue == solution.getCost())) {
                    // no new best solution has been found =(
                    ++noNewSoln;
                    if (noNewSoln == maxNoNewSoln) {
                        // increase sub-problem size
                        noNewSoln = 0;
                        ++neighborhoodSize;
                    }
                }
                if (neighborhoodSize >= inst.nSlots) {
                    // solution is proven optimal!
                    System.out.println(String.format("Solution is optimal! Cost: %f", objValue));
                }
            }
            else { // sub-problem is too hard for timeLimit - reduce its size
                --neighborhoodSize;
                noNewSoln = 0;
            }

            // export solution
            this.mip.exportSolution(solution);
        } catch (GRBException e) {
            e.printStackTrace();
        }
        return deltaCost = solution.getCost() - initialTotalCost;
    }

}
