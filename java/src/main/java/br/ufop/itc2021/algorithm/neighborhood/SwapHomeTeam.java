package br.ufop.itc2021.algorithm.neighborhood;

import br.ufop.itc2021.model.*;
import br.ufop.itc2021.util.*;

import java.util.*;

/**
 * This class represents a SwapHomeTeam move. A neighbor in this neighborhood is
 * generated by swapping two games of the same teams thereby inverting which team
 * plays at home first.
 *
 * @author Tulio Toffolo
 */
public class SwapHomeTeam extends MoveToCompound {

    private final List<Game> moves;
    private int nMoves;

    private Game game1, game2;
    private int slot1, slot2;

    /**
     * Instantiates a new SwapHomeTeam Move.
     *
     * @param inst     problem.
     * @param random   random number generator.
     * @param weight the weight of this neighborhood.
     */
    public SwapHomeTeam(Instance inst, Random random, int weight) {
        super(inst, random, "SwapHomeTeam", weight);

        moves = new ArrayList<>(inst.nGames / 2);
        for (int g = 0; g < inst.nGames / 2; g++)
            moves.add(inst.games[g]);
        nMoves = moves.size();
    }

    public void accept() {
        super.accept();
    }

    public long doMove(Solution solution) {
        super.doMove(solution);

        // randomly selecting game and its 'counterpart'
        int randomMove = random.nextInt(nMoves);
        game1 = moves.get(randomMove);
        game2 = inst.getGame(game1.away, game1.home);
        slot1 = solution.gameSlot[game1.id];
        slot2 = solution.gameSlot[game2.id];

        // removing selected game and updating number of remaining ones
        Util.swap(moves, randomMove, --nMoves);

        // executing move...
        solution.setGame(game1, slot2);
        solution.setGame(game2, slot1);

        if (!inChain) solution.updateCost();

        return deltaCost = solution.getCost() - initialTotalCost;
    }

    public boolean hasMove(Solution solution) {
        if (inChain && nMoves == 0) reset();
        return nMoves > 0;
    }

    public void reject() {
        super.reject();

        solution.setGame(game1, slot1);
        solution.setGame(game2, slot2);
        //solution.updateCost();
        if (!inChain) solution.forceUpdateCost(initialInfeas, initialFeasCost);
    }

    public void reset() {
        super.reset();
        nMoves = moves.size();
    }
}
