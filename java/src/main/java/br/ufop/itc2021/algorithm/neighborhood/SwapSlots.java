package br.ufop.itc2021.algorithm.neighborhood;

import br.ufop.itc2021.model.*;
import br.ufop.itc2021.util.*;
import org.apache.commons.math3.util.*;

import java.util.*;

/**
 * This class represents a SwapSlots move. A neighbor in this neighborhood is
 * generated by swapping all games of two slots.
 *
 * @author Tulio Toffolo
 */
public class SwapSlots extends MoveToCompound {

    private final List<Pair<Integer, Integer>> moves;
    private int nMoves;

    private Game[] gamesSlot1, gamesSlot2;
    private int slot1, slot2;

    /**
     * Instantiates a new SwapHomeTeam Move.
     *
     * @param inst     problem.
     * @param random   random number generator.
     * @param weight the weight of this neighborhood.
     */
    public SwapSlots(Instance inst, Random random, int weight) {
        super(inst, random, "SwapSlots", weight);

        // enumerating possible moves
        moves = new ArrayList<>();
        if (inst.phased) {
            for (int s1 = 0; s1 < inst.nSlots / 2; s1++)
                if (s1 < inst.nSlots / 2)
                    for (int s2 = s1 + 1; s2 < inst.nSlots / 2; s2++)
                        moves.add(new Pair<>(s1, s2));
                else
                    for (int s2 = s1 + 1; s2 < inst.nSlots; s2++)
                        moves.add(new Pair<>(s1, s2));
        }
        else {
            for (int s1 = 0; s1 < inst.nSlots; s1++)
                for (int s2 = s1 + 1; s2 < inst.nSlots; s2++)
                    moves.add(new Pair<>(s1, s2));
        }
        nMoves = moves.size();

        // creating auxiliary data structures
        gamesSlot1 = new Game[inst.nTeams / 2];
        gamesSlot2 = new Game[inst.nTeams / 2];
    }

    public void accept() {
        super.accept();
    }

    public long doMove(Solution solution) {
        super.doMove(solution);

        // randomly selecting game and its 'counterpart'
        int randomSwap = random.nextInt(nMoves);
        slot1 = moves.get(randomSwap).getFirst();
        slot2 = moves.get(randomSwap).getSecond();

        // removing selected game and updating number of remaining ones
        Util.swap(moves, randomSwap, --nMoves);

        // getting current games
        for (int g = 0; g < inst.nTeams / 2; g++) {
            gamesSlot1[g] = solution.gamesPerSlot.get(slot1).get(g);
            gamesSlot2[g] = solution.gamesPerSlot.get(slot2).get(g);
        }

        // removing all games
        for (Game game : gamesSlot1)
            solution.setGame(game, slot2);
        for (Game game : gamesSlot2)
            solution.setGame(game, slot1);

        if (!inChain) solution.updateCost();

        return deltaCost = solution.getCost() - initialTotalCost;
    }

    public boolean hasMove(Solution solution) {
        if (inChain && nMoves == 0) reset();
        return nMoves > 0;
    }

    public void reject() {
        super.reject();

        // removing all games
        for (Game game : gamesSlot1)
            solution.setGame(game, slot1);
        for (Game game : gamesSlot2)
            solution.setGame(game, slot2);

        //solution.updateCost();
        if (!inChain) solution.forceUpdateCost(initialInfeas, initialFeasCost);
    }

    public void reset() {
        super.reset();
        nMoves = moves.size();
    }
}
