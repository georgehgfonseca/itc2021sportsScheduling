package br.ufop.itc2021.algorithm.neighborhood;

import br.ufop.itc2021.model.*;
import br.ufop.itc2021.util.*;

import java.util.*;

/**
 * This class represents a SwapTeams move. A neighbor in this neighborhood is
 * generated by swapping all games of two randomly selected teams in all slots.
 *
 * @author Tulio Toffolo
 */
public class SwapTeams extends MoveToCompound {

    private final List<Swap> moves;
    private int nMoves;

    private Swap swap;

    /**
     * Instantiates a new SwapTeams Move.
     *
     * @param inst     problem.
     * @param random   random number generator.
     * @param weight the weight of this neighborhood.
     */
    public SwapTeams(Instance inst, Random random, int weight) {
        super(inst, random, "SwapTeams", weight);

        moves = new ArrayList<>(inst.nTeams * (inst.nTeams - 1) / 2);
        for (int i = 0; i < inst.nTeams; i++)
            for (int j = i + 1; j < inst.nTeams; j++)
                moves.add(new Swap(i, j));
        nMoves = moves.size();
    }

    public void accept() {
        super.accept();
    }

    public long doMove(Solution solution) {
        super.doMove(solution);

        // randomly selecting teams and updating number of remaining ones
        int randomMove = random.nextInt(nMoves);
        Util.swap(moves, randomMove, --nMoves);

        swap = moves.get(randomMove);

        // removing selected game
        for (int s = 0; s < inst.nSlots; s++) {
            Game g1 = solution.gamesPerTeam[swap.team1][s];
            Game g2 = solution.gamesPerTeam[swap.team2][s];
            if (g1 != g2) {
                if (g1.home == swap.team1)
                    solution.setGame(inst.getGame(swap.team2, g1.away), s);
                else
                    solution.setGame(inst.getGame(g1.home, swap.team2), s);

                if (g2.home == swap.team2)
                    solution.setGame(inst.getGame(swap.team1, g2.away), s);
                else
                    solution.setGame(inst.getGame(g2.home, swap.team1), s);
            }
        }

        if (!inChain) solution.updateCost();

        return deltaCost = solution.getCost() - initialTotalCost;
    }

    public boolean hasMove(Solution solution) {
        if (inChain && nMoves == 0) reset();
        return nMoves > 0;
    }

    public void reject() {
        super.reject();

        for (int s = 0; s < inst.nSlots; s++) {
            Game g1 = solution.gamesPerTeam[swap.team1][s];
            Game g2 = solution.gamesPerTeam[swap.team2][s];
            if (g1 != g2) {
                if (g1.home == swap.team1)
                    solution.setGame(inst.getGame(swap.team2, g1.away), s);
                else
                    solution.setGame(inst.getGame(g1.home, swap.team2), s);

                if (g2.home == swap.team2)
                    solution.setGame(inst.getGame(swap.team1, g2.away), s);
                else
                    solution.setGame(inst.getGame(g2.home, swap.team1), s);
            }
        }

        if (!inChain) solution.forceUpdateCost(initialInfeas, initialFeasCost);
    }

    public void reset() {
        super.reset();
        nMoves = moves.size();
    }

    private class Swap {

        public final int team1, team2;

        public Swap(int team1, int team2) {
            this.team1 = team1;
            this.team2 = team2;
        }
    }
}
